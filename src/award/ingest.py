"""Document ingestion module."""

import hashlib
import json
from pathlib import Path
from pprint import pp

import meilisearch
import pymupdf

from award.utils import find_files_with_extensions, get_document_code_description

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")


@dataclass
class DocumentIndexer:
    """A class used to index documents from a directory.

    Attributes
    ----------
    directory : Path
        The directory containing the documents to be indexed.
    input : Path, optional
        The path to the input file containing a pre-existing index (default is None).
    output : Path, optional
        The path to the output file where the index will be saved (default is None).
    index : dict
        A dictionary to store the document index.
    reduced_index : set
        A set to store a reduced version of the document index for faster lookups.

    Methods
    -------
    __post_init__():
        Loads the index from the input file if provided.
    load_index():
        Loads the document index from the input file.
    get_document_meta(file_path: Path | str) -> dict:
        Extracts metadata from a document.
    dir2index() -> dict:
        Indexes all documents in the directory and optionally saves the index to the output file.

    """

    directory: Path
    input: Path = None
    output: Path = None
    index: dict = field(default_factory=dict)
    reduced_index: set = field(default_factory=set)

    def __post_init__(self):  # noqa: D105
        if self.input:
            self.load_index()

    def _update_reduced_index(self):
        self.reduced_index = {doc["id"] for doc in self.index}

    def load_index(self):
        """Load the document index from a JSON file specified by the `input` attribute.

        This method reads the JSON file, updates the `index` attribute with the
        contents of the file, and then calls the `_update_reduced_index` method
        to further process the index. It also logs an informational message
        indicating that the document index has been loaded.

        Raises:
            FileNotFoundError: If the file specified by `input` does not exist.
            json.JSONDecodeError: If the file is not a valid JSON.

        """
        with open(self.input, "r") as file:
            self.index = json.load(file)
            self._update_reduced_index()
        logging.info("Loaded document index from file %s", self.input)

    def get_document_meta(self, file_path: Path | str) -> dict:
        """Extract metadata and text content from a document.

        Args:
            file_path (Path | str): The path to the document file.

        Returns:
            dict: A dictionary containing the following keys:
                - id (int): A unique identifier for the document, generated by hashing the file path.
                - code (str): A code representing the document.
                - description (str): A description of the document.
                - pages (dict): A dictionary where the keys are page numbers (starting from 1) and
                the values are the text content of each page.

        Raises:
            pymupdf.FileDataError: If there is an error with the file data.
            pymupdf.mupdf.FzErrorUnsupported: If the file format is unsupported.
            Exception: For any other unexpected errors.

        """
        file_path = Path(file_path)
        id = hash_string(str(file_path))
        code, description = get_document_code_description(file_path)

        try:
            with pymupdf.open(file_path) as document:
                pages = {i: t.get_text() for (i, t) in enumerate(document, 1)}
        except (pymupdf.FileDataError, pymupdf.mupdf.FzErrorUnsupported) as e:
            logging.error(f"Error opening document {file_path}: {e}")
            pages = {}
        except Exception as e:
            logging.error(f"Unexpected error processing document {file_path}: {e}")
            pages = {}
        return dict(id=id, code=code, description=description, pages=pages)

    def update(self, input: Path) -> dict:
        """Update the index with metadata from files found in the given input path.

        Args:
            input (Path): The path to the directory containing files to be indexed.

        The method performs the following steps:
        1. Converts the input to a Path object.
        2. Finds files with specific extensions in the input directory.
        3. Retrieves metadata for each file that is not already in the reduced index.
        4. Extends the current index with the new metadata.
        5. Updates the reduced index.

        """
        input = Path(input)
        files = find_files_with_extensions(input)
        update_with = [
            self.get_document_meta(file)
            for file in files
            if hash_string(file) not in self.reduced_index
        ]
        self.index.extend(update_with)
        self._update_reduced_index()

    def export(self, output: Path):
        """Export the index to a JSON file."""
        with open(output, "w") as file:
            json.dump(self.index, file, indent=4)


def hash_string(input_string: str | Path) -> str:
    """Generate a SHA-256 hash for the given input string.

    Args:
        input_string (str): The string to hash.

    Returns:
        str: The resulting SHA-256 hash as a hexadecimal string.

    """
    sha256_hash = hashlib.sha256()
    sha256_hash.update(input_string.encode("utf-8"))
    return sha256_hash.hexdigest()


def get_document_meta(file_path: Path | str) -> dict:
    """Extract metadata from a document.

    Args:
        file_path (Path | str): The path to the document file.

    Returns:
        dict: A dictionary containing the document's code number,
        description, and text, one field per page.

    """
    file_path = Path(file_path)
    code, description = get_document_code_description(file_path)

    try:
        document = pymupdf.open(file_path)
    except pymupdf.FileDataError:
        return dict(id=code, description=description, pages={})
    pages = {i: t.get_text() for (i, t) in enumerate(document, 1)}
    return dict(id=code, description=description, pages=pages)


def dir2index(directory: Path, output: Path = None) -> dict:
    """Convert a directory of documents to an index compatible with Meilisearch."""
    directory = Path(directory)
    files = find_files_with_extensions(directory)
    d = [get_document_meta(file) for file in files]

    if output:
        with open(output, "w") as file:
            json.dump(d, file, indent=4)

    return d


if __name__ == "__main__":
    pdf = Path(
        "assets/testfiles/009126_00038255_3_Brown University Requisition No. 04199154 Contract Draft_RN_03.29.23.pdf"
    )
    directory = Path("assets/testfiles")

    index = dir2index(directory, output="index.json")

    client = meilisearch.Client("http://localhost:7700", "aSampleMasterKey")

    json_file = open("index.json", encoding="utf-8")
    docs = json.load(json_file)
    # client.index('pdfs1').add_documents(docs)
    client.index("pdfs1").add_documents(index)

    pp(client.index("pdfs1").search("funambulo"))
    pp(client.index("pdfs1").search("foobarbaz"))
